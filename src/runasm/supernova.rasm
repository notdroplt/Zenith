ISA supernova:64

width 64

registers 32:2
	r0:64 r1:64
	r2:64 r3:64
	r4:64 r5:64
	r6:64 r7:64
	r8:64 r9:64
	r10:64 r11:64
	r12:64 r13:64
	r14:64 r15:64
	r16:64 r17:64
	r18:64 r19:64
	r20:64 r21:64
	r22:64 r23:64
	r24:64 r25:64
	r26:64 r27:64
	r28:64 r29:64
	r30:64 r31:64
	pc:64 intvec:64
registers 

reg_properties
	r0 fixed 0
	pc readonly
reg_properties

format r_instruction as
	00000000000000000000000000000000000000000rrrrrRRRRRdddddoooooooo
	where
		0 : padding	
		r : r2
		R : r1
		d : rd 
		o : opcode 

format s_instruction as
	iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiirrrrrdddddoooooooo
	where 
		i : imm 
		r : r1 
		d : rd 
		o : opcode 

format l_instruction as 
	iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiidddddoooooooo
	where 
		i : imm
		d : rd 
		o : opcode 

#######################################

instruction ANDR : 00 : r_instruction 
	! rd <- r1 & r2 

instruction ANDI : 01 : s_instruction does
	rd <- r1 & 0:imm
ends 

instruction XORR : 02 : r_instruction does
	rd <- r1 ^ r2 
ends 

instruction XORI : 03 : s_instruction does
	rd <- r1 ^ 0:imm 
ends 

###

instruction ORR  : 04 : r_instruction  
	! rd <- r1 | r2
 
instruction ORI  : 05 : s_instruction  
	! rd <- r1 | 0:imm 

###

instruction ADDR : 10 : r_instruction  
	! rd <- r1 + r2 

instruction ADDI : 11 : s_instruction  
	! rd <- r1 + 0:imm 

instruction SUBR : 12 : r_instruction  
	! rd <- r1 - r2 

instruction SUBI : 13 : s_instruction  
	! rd <- r1 - 0:imm 

###

instruction UMULR : 14 : r_instruction  
	! rd <- r1 * r2 

instruction UMULI : 15 : s_instruction  
	! rd <- r1 * 0:imm 

instruction SMULR : 16 : r_instruction  
	! rd <- (sig)r1 * (sig)r2 

instruction SMULI : 17 : s_instruction  
	! rd <- (sig)r1 * sig:imm 

###

instruction UDIVR : 18 : r_instruction  
	! rd <- r1 / r2 
	? [r2] == 0 

instruction UDIVI : 19 : s_instruction  
	! rd <- r1 / 0:imm 
	? imm == 0 

instruction SDIVR : 1A : r_instruction  
	! rd <- (sig)r1 / (sig)r2 
	? [r2] == 0

instruction SDIVI : 1B : s_instruction  
	! rd <- (sig)r1 / sig:imm 
	? imm == 0

### 

instruction CALL : 1C : r_instruction 
	! *64(r1 + 0) <- r2 
	! *64(r2 + 8) <- pc + 8
	! r1 <- r1 + 16
	! r2 <- r1 
	! pc <- rd 

instruction PUSH : 1D : s_instruction 
	! *64(rd) <- r1 + imv 
	! rd <- rd + 8

instruction RETN : 1E : r_instruction
	! r1 <- r1 - 16 
	! r2 <- u64[r1 + 0]
	! pc <- u64[r1 + 8]

instruction LODB : 20 : s_instruction  
	! rd <- @8(r1 + 0:imm)

instruction LODH : 21 : s_instruction  
	! rd <- @16(r1 + 0:imm)
 
instruction LODW : 22 : s_instruction  
	! rd <- @32(r1 + 0:imm)
 
instruction LODD : 23 : s_instruction  
	! rd <- @64(r1 + 0:imm)
 
instruction STRB : 24 : s_instruction 
	! @8(rd + 0:imm) <- r1  

instruction STRH : 25 : s_instruction  
	! @16(rd + 0:imm) <- r1   

instruction STRW : 26 : s_instruction  
	! @32(rd + 0:imm) <- r1   

instruction STRD : 27 : s_instruction  
	! @64(rd + 0:imm) <- r1   