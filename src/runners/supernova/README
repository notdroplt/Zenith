# supernova instruction set

this is a reduced instruction set I designed to be the first target
to be compiled on zenith, instructions can change place/meaning in future releases

## instruction layouts (blank spaces are continuation of immediates):

| instruction type | bytes 63 - 23 | 22 - 18 | 17 - 13 | 12 - 8 | 7 - 0 | 
| :--------------: | :-----------: | :-----: | :-----: | :----: | :---: |
|     R type       |   (ignored)   |   r2    |   rd    |   r1   |  op   |
|     S type       |   immediate   |         |   rd    |   r1   |  op   | 
|     L type       |      |      immediate      |      |   r1   |  op   | 

## register layouts 

registers that dont have a defined designation are used as function parameters, going bottom to top:

| register index | function |
| :-: | :-: |
| r00 | zero register | 
| r01 | stack pointer | 
| r02 | frame pointer | 
| r03 | constant area pointer |

| r03 - r31 | arguments | 

## interrupts

### default interrupts/exceptions used by the virtual machine

* `ecall 0`: [see below](#ecall-0)
* `ecall 1`: divison by zero
* `ecall 2`: general fault
* `ecall 3`: no I/O device
* `ecall 4`: too far memory read/write

## `ecall 0`
only `ecall 0` is hardware/vm defined, all the other $2^{51}-1$ possible interrupts are programmable with a call to `ecall 0`:

### `ecall 0`, `r31 = ptr`, `r30 = count`, `r29 = 0`:
- sets address on `r31` as the interrupt vector with entry count set on `r30`.
- note: an interrupt entry has 24 bytes instead of 8 for a pointer.

### `ecall 0`, `r31 = idx`, `r30 = ptr#1`, `r29 = 1`, `r28 = ptr#2`, `r27 = flags`:
- this call formats an interrupt entry, in the following format:
    - [`base-ptr + idx * 24 + 0x00`] = pointer to code to call interrupt (`r30`) **inside virtual machine**: 8 bytes.
    - [`base-ptr + idx * 24 + 0x08`] = pointer to code to call interrupt (`r28`) **outside virtual machine**: 8 bytes.
    - [`base-ptr + idx * 24 + 0x10`] = interrupt flags: 8 bytes (aligned)
        - flags can be any of the following:
            - `1 << 0`: call native virtual machine interrupt pointer.
            - `1 << 1`: call outside virtual machine interrupt pointer.
            - `1 << 2`: call native interrupt pointer first.
            - `1 << 3`: call native interrupt pointer last (default).
        - if either only native or outsider flags are set, their respective arguments can be set or not, but surely ignored on interrupt calls.

### `ecall 0`, `r31 = path`, `r30 = arr`, `r29 = 2`, `r28 = size`: 
- this call loads a dynamic library outside the virtual machine given path (`r31`)
- if `r28` is non-zero, the virtual machine will only load interrupts indexed in `r30`, else if `r28 = 0`, `r30` is ignored and all interrupts given by the library are loaded
- `r31` is set with library index, which is used on other functions instead of path

### `ecall 0`, `r31 = libidx`, `r30 = idx`, `r29 = 3`:
- this call will get the pointer of an interrupt of a library and put it into both `r03` and `r28`

### `ecall 0`, `r31 = libidx`, `r29 = 4`:
- this call unloads a library given its index

### dynamic library loading API/ABI

on a successfull call to `ecall 0` `r29 = 2` , the virtual machine will call a native dynamic library loader
(for example `ldl` on Linux) and load a given file fiven by the string on `r31`. After that, the virtual machine
will look for two symbols: `sn[version]libint_loader` and `snlibint_loader`, 
preferring the first one. That symbol must be a function which returns `snlibintlret_t`, defined as follows: 

```c
/* assume necessary header(s) are included */

typedef void (*int_func_t)(struct supernova_thread_t *);

typedef struct {
    uint64_t index;
    int_func_t pointer;
} intp_t;

typedef struct {
    uint64_t interrupt_count;
    intp_t interrupts[];
} snlibintlret_t;
```

on successful loading, the virtual machine will assign the loaded value an index, and return it in both `r03` and `r28`

## Instruction Set Resume


- group zero: bitwise instruction group [opcodes `0x00 - 0x0F`] 
    - andr: [opcode `0x00`, R type]
        - executes a bitwise AND between `r1` and `r2`, result on `rd`
        - mnemonic: `rd <- r1 & r2`

    - andi: [opcode `0x01`, S type]
        - executes a bitwise AND between `r1` and a mask immediate, result on `rd`
        - mnemonic: `rd <- r1 & imm`

    - xorr: [opcode `0x02`, R type]
        - executes a bitwise XOR between `r1` and `r2`, result on `rd`
        - mnemonic: `rd <- r1 ^ r2`

    - xori: [opcode `0x03`, S type]
        - executes a bitwise XOR between `r1` and a mask immediate, result on `rd`
        - mnemonic: `rd <- r1 ^ imm`
    
    - orr: [opcode `0x04`, R type]
        - executes a bitwise OR between `r1` and `r2`, result on `rd`
        - mnemonic: `rd <- r1 | r2`

    - ori: [opcode `0x05`, S type]
        - executes a bitwise OR between `r1` and a mask immediate, result on `rd`
        - mnemonic: `rd <- r1 | imm`

    - **Reserved for alignment [opcode `0x06`, R type]**

    - cnt [opcode `0x07`, S type]
        - executes a population count on register `r1`, excluding the highest `imm` bits, result on `rd`
        - mnemonic: `rd <- popcnt(r1 & ((1 << imm) - 1))`
        - edge case:
            - if `imm >= 64`, clear `rd`

    - llsr [opcode `0x08`, R type] 
        - executes a logical left shift on register `r1` for `r2` bits, result on `rd`
        - mnemonic: `rd <- r1 << r2`
        - edge case:
            - if `r2 >= 64`, clear `rd`
    
    - llsi [opcode `0x09`, S type] 
        - executes a logical left shift on register `r1` for `imm` bits, result on `rd`
        - mnemonic: `rd <- r1 << imm`
        - edge case:
            - if `imm >= 64`, clear `rd`

    - lrsr [opcode `0x0A`, R type] 
        - executes a logical right shift on register `r1` for `r2` bits, result on `rd`
        - mnemonic: `rd <- r1 >> r2`
        - edge case:
            - if `r2 >= 64`, clear `rd`
    
    - lrsi [opcode `0x0B`, S type] 
        - executes a logical right shift on register `r1` for `imm` bits, result on `rd`
        - mnemonic: `rd <- r1 >> imm`
        - edge case:
            - if `imm >= 64`, clear `rd`

    - alsr [opcode `0x0C`, R type] 
        - executes a arithmetical left shift on register `r1` for `r2` bits, result on `rd`
        - mnemonic: `rd <- r1 <<< r2`
        - edge case:
            - if `r2 >= 64`, clear `rd`
    
    - alsi [opcode `0x0D`, S type] 
        - executes a arithmetical left shift on register `r1` for `imm` bits, result on `rd`
        - mnemonic: `rd <- r1 <<< imm`
        - edge case:
            - if `imm >= 64`, clear `rd`

    - arsr [opcode `0x0E`, R type] 
        - executes a arithmetical right shift on register `r1` for `r2` bits, result on `rd`
        - mnemonic: `rd <- r1 >>> r2`
        - edge case:
            - if `r2 >= 64`, clear `rd`
    
    - arsi [opcode `0x0F`, S type] 
        - executes a arithmetical right shift on register `r1` for `imm` bits, result on `rd`
        - mnemonic: `rd <- r1 >>> imm`
        - edge case:
            - if `imm >= 64`, clear `rd`

- group one: 
    - addr [opcode `0x10`, R type] 
        - adds `r2` to `r1` and set `rd` as the result
        - mnemonic: `rd <- r1 + r2`
        - edge case:
            - overflow is discarted
    
    - addi [opcode `0x11`, S type] 
        - adds `imm` to `r1` and set `rd` as the result
        - mnemonic: `rd <- r1 + imm`
        - edge case:
            - overflow is discarted

    - subr [opcode `0x12`, R type] 
        - subtracts `r2` from `r1` and set `rd` as the result
        - mnemonic: `rd <- r1 - r2`
        - edge case:
            - overflow is discarted
    
    - subi [opcode `0x13`, S type] 
        - subtracts `imm` from `r1` and set `rd` as the result
        - mnemonic: `rd <- r1 - imm`
        - edge case:
            - overflow is discarted
    
    - umulr [opcode `0x14`, R type] 
        - multiplies `r2 (unsigned)` with `r1 (unsigned)` and set `rd` as the result
        - mnemonic: `rd <- (uint64_t)r1 * (uint64_t)r2`
        - edge case:
            - overflow is discarted
    
    - umuli [opcode `0x15`, S type] 
        - multiplies `imm (unsigned)` with `r1 (unsigned)` and set `rd` as the result
        - mnemonic: `rd <- (uint64_t)r1 * (uint64_t)imm`
        - edge case:
            - overflow is discarted

    - smulr [opcode `0x16`, R type] 
        - multiplies `r2 (signed)` with `r1 (signed)` and set `rd` as 
        - mnemonic: `rd <- (int64_t)r1 * (int64_t)r2`
        - edge case:
            - overflow is discarted
    
    - smuli [opcode `0x17`, S type] 
        - multiplies `imm` with `r1` and set `rd` as the result
        - mnemonic: `rd <- (int64_t)r1 * (int64_t)imm`
        - edge case:
            - overflow is discarted

    - udivr [opcode `0x18`, R type] 
        - divides `r1 (unsigned)` by `r2 (unsigned)` and set `rd` as the result
        - mnemonic: `rd <- (uint64_t)r1 / (uint64_t)r2`
        - edge case:
            - overflow is discarted
            - `r2 = 0` triggers `ecall 1`
    
    - udivi [opcode `0x19`, S type] 
        - divides `r1 (unsigned)` by `imm (unsigned)` and set `rd` as the result
        - mnemonic: `rd <- (uint64_t)r1 / (uint64_t)imm`
        - edge case:
            - overflow is discarted
            - `imm = 0` triggers `ecall 1`

    - sdivr [opcode `0x1A`, R type] 
        - divides `r1 (signed)` by `r2 (signed)` and set `rd` as 
        - mnemonic: `rd <- (int64_t)r1 / (int64_t)r2`
        - edge case:
            - overflow is discarted
            - `r2 = 0` triggers `ecall 1`
    
    - sdivi [opcode `0x1B`, S type] 
        - divides `r1 (signed)` by `imm (signed)` and set `rd` as the result
        - mnemonic: `rd <- (int64_t)r1 / (int64_t)imm`
        - edge case:
            - overflow is discarted
            - `imm = 0` triggers `ecall 1`

    - call [opcode `0x1C`, R type]
        - change execution context to another place
        - semantic renaming: `call rd, r1, r2` -> `call addr, sp, bp`
        - mnemonic:
            - `u64[sp + 0] <- bp`
            - `u64[sp + 8] <- pc + 8` 
            - `sp <- sp + 16`
            - `bp <- sp`
            - `pc <- addr`

    - push [opcode `0x1D`, S type]
        - push a value into given stack
        - semantic renaming `push rd, r1, imm` -> `push sp, rv, imv`
        - mnemonic:
            - `u64[sp] <- rv + imv`
            - `sp <- sp + 8`

    - retn [opcode `0x1E`, R type]
        - return execution to previous context
        - semantic renaming `retn rd, r1, r2` -> `retn x0, sp, bp`
        - mnemonic:
            - `sp <- sp - 16`
            - `bp <- u64[sp + 0]`
            - `pc <- u64[sp + 8]`
        - `rd` is ignored
    
    - pull [opcode `0x1F`, S type]
        - pull a value out of a given stack
        - semantic renaming `pull rd, r1, imm` -> `pull rd, sp, imm`
        - mnemonic: 
            - `rd <- u64[sp - 8]`
            - `sp <- sp - 8`
        - `imm` is ignored

- group two:
    - ldb [opcode `0x20`, S type]
        - load byte from memory into a register
        - mnemonic: `rd <- r0 | u8[r1 + imm]`
        - side effects:
            - if `r1 + imm` is bigger than memory size, `ecall 4` is triggered

    - ldh [opcode `0x21`, S type]
        - load half word from memory into a register
        - mnemonic: `rd <- r0 | u16[r1 + imm]`
        - side effects:
            - if `r1 + imm` is bigger than memory size, `ecall 4` is triggered

    - ldw [opcode `0x22`, S type]
        - load word from memory into a register
        - mnemonic: `rd <- r0 | u32[r1 + imm]`
        - side effects:
            - if `r1 + imm` is bigger than memory size, `ecall 4` is triggered
            
    - ldh [opcode `0x23`, S type]
        - load double word from memory into a register
        - mnemonic: `rd <- u64[r1 + imm]`
        - side effects:
            - if `r1 + imm` is bigger than memory size, `ecall 4` is triggered

    - stb [opcode `0x24`, S type]
        - store byte from register into memory
        - mnemonic: `u8[rd + imm] <- r1 & 0xff`
        - side effects:
            - if `rd + imm` is bigger than memory size, `ecall 4` is triggered

    - sth [opcode `0x25`, S type]
        - store half word from register into memory
        - mnemonic: `u16[rd + imm] <- r1 & 0xffff`
        - side effects:
            - if `rd + imm` is bigger than memory size, `ecall 4` is triggered

    - stw [opcode `0x26`, S type]
        - store word from register into memory
        - mnemonic: `u32[rd + imm] <- r1 & 0xffffffff`
        - side effects:
            - if `rd + imm` is bigger than memory size, `ecall 4` is triggered

    - sth [opcode `0x25`, S type]
        - store half word from register into memory
        - mnemonic: `u64[rd + imm] <- r2`
        - side effects:
            - if `rf + imm` is bigger than memory size, `ecall 4` is triggered